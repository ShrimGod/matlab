%% Method 12 Enhanced: Comprehensive Standing Wave Removal and Verification
% Advanced multi-scale phase coherence analysis with integrated verification
% This script provides multiple methods to remove standing waves and
% definitively verify their removal through various analytical approaches
%
% INPUTS REQUIRED:
%   Data - 3D array (nx x ny x nt) containing ultrasonic scan data
%   x, y - spatial coordinate vectors
%   t - time vector
%   fs - sampling frequency (Hz)
%
% OUTPUTS:
%   Data_comprehensive_filt - Comprehensively filtered data
%   standing_wave_analysis - Complete analysis structure
%   Multiple verification plots and metrics

clear; clc;

%% ============================================================================
%% SETUP AND PARAMETERS
%% ============================================================================

% Load your data here - uncomment and modify as needed
% load('your_data_file.mat'); % Should contain Data, x, y, t

% Sampling and frequency parameters
fs = 50e6;              % Sampling frequency (50 MHz typical)
f_standing = 5e6;       % Expected standing wave frequency

% Time gates for analysis
toi1 = 120;             % First time of interest (μs)
toi2 = 124;             % Second time of interest (μs)

% Analysis position
defect_x = 32;          % X position for detailed analysis
defect_y = 60;          % Y position for detailed analysis

% Enhanced phase analysis parameters
freq_range = [2e6, 8e6];    % Wider frequency range for better detection
coherence_scales = [3, 5, 7]; % Multi-scale coherence analysis
phase_reduction_factor = 0.05; % Stronger reduction (5% of original)

% Adaptive filtering parameters
use_adaptive_threshold = true;  % Enable local adaptive thresholding
local_window_size = 20;        % Window for local statistics
coherence_sensitivity = 2.0;   % Standard deviations above mean

%% ============================================================================
%% DATA VERIFICATION AND INITIALIZATION
%% ============================================================================

% Verify data exists
if ~exist('Data', 'var')
    error('Data variable not found. Please load your ultrasonic data first.');
end

[nx, ny, nt] = size(Data);
fprintf('=== METHOD 12 ENHANCED: COMPREHENSIVE STANDING WAVE REMOVAL ===\n');
fprintf('Data dimensions: %dx%dx%d\n', nx, ny, nt);

% Create coordinate vectors if needed
if ~exist('x', 'var') || ~exist('y', 'var') || ~exist('t', 'var')
    warning('Coordinate vectors not found. Creating default vectors.');
    x = 0:nx-1;
    y = 0:ny-1;
    t = (0:nt-1) / fs * 1e6; % Convert to microseconds
end

fprintf('Spatial range: X=[%.2f,%.2f], Y=[%.2f,%.2f]\n', min(x), max(x), min(y), max(y));
fprintf('Time range: %.2f to %.2f μs\n', min(t), max(t));

% Calculate time indices
[~,i1] = min(abs(t-toi1));
[~,i2] = min(abs(t-toi2));
actual_toi1 = t(i1);
actual_toi2 = t(i2);

%% ============================================================================
%% ENHANCED MULTI-SCALE PHASE ANALYSIS
%% ============================================================================

fprintf('\n=== PERFORMING ENHANCED MULTI-SCALE PHASE ANALYSIS ===\n');

% FFT parameters with better resolution
zero_pad_factor = 4;  % Increased zero-padding for frequency resolution
nfft = 2^nextpow2(nt) * zero_pad_factor;
freq_axis = (0:nfft-1) * fs / nfft;
freq_indices = find(freq_axis >= freq_range(1) & freq_axis <= freq_range(2));

fprintf('Enhanced FFT length: %d (%.1fx zero-padding)\n', nfft, nfft/nt);
fprintf('Frequency resolution: %.2f kHz\n', fs/nfft/1000);
fprintf('Analysis frequency range: %.1f-%.1f MHz (%d bins)\n', ...
    freq_range(1)/1e6, freq_range(2)/1e6, length(freq_indices));

% Initialize enhanced arrays
Phase_Data = zeros(nx, ny, length(freq_indices));
Amplitude_Data = zeros(nx, ny, length(freq_indices));
multi_scale_coherence = zeros(nx, ny, length(freq_indices));

% Compute pixel-wise FFT with windowing
fprintf('Computing windowed FFT analysis...\n');
window = hann(nt);  % Hann window to reduce spectral leakage

tic;
for i = 1:nx
    if mod(i,10) == 0
        fprintf('  Progress: %d/%d (%.1fs elapsed)\n', i, nx, toc);
    end
    for j = 1:ny
        % Apply window to signal
        signal = squeeze(Data(i,j,:)) .* window;
        
        % Compute FFT with zero-padding
        fft_signal = fft(signal, nfft);
        
        % Extract phase and amplitude in frequency range
        fft_roi = fft_signal(freq_indices);
        Phase_Data(i,j,:) = angle(fft_roi);
        Amplitude_Data(i,j,:) = abs(fft_roi);
    end
end
fprintf('FFT computation completed in %.1f seconds\n', toc);

%% ============================================================================
%% MULTI-SCALE PHASE COHERENCE ANALYSIS
%% ============================================================================

fprintf('\n=== COMPUTING MULTI-SCALE PHASE COHERENCE ===\n');

tic;
for scale_idx = 1:length(coherence_scales)
    window_size = coherence_scales(scale_idx);
    half_window = floor(window_size/2);
    
    fprintf('Processing scale %d/%d (window size %dx%d)...\n', ...
        scale_idx, length(coherence_scales), window_size, window_size);
    
    for f = 1:length(freq_indices)
        if mod(f,20) == 0 && scale_idx == 1
            fprintf('  Frequency %d/%d\n', f, length(freq_indices));
        end
        
        phase_slice = Phase_Data(:,:,f);
        
        % Compute coherence at this scale
        for i = half_window+1:nx-half_window
            for j = half_window+1:ny-half_window
                % Extract neighborhood
                neighborhood = phase_slice(i-half_window:i+half_window, ...
                                         j-half_window:j+half_window);
                
                % Calculate circular variance (more appropriate for phase)
                exp_phases = exp(1i * neighborhood(:));
                R = abs(mean(exp_phases));  % Resultant vector length
                circular_variance = 1 - R;
                
                % Accumulate coherence (inverse variance)
                multi_scale_coherence(i,j,f) = multi_scale_coherence(i,j,f) + ...
                    1/(circular_variance + 1e-6);
            end
        end
    end
end

% Normalize by number of scales
multi_scale_coherence = multi_scale_coherence / length(coherence_scales);
fprintf('Multi-scale coherence analysis completed in %.1f seconds\n', toc);

%% ============================================================================
%% ADAPTIVE THRESHOLD CALCULATION
%% ============================================================================

fprintf('\n=== CALCULATING ADAPTIVE THRESHOLDS ===\n');

standing_wave_mask_adaptive = zeros(nx, ny, length(freq_indices));

if use_adaptive_threshold
    fprintf('Using local adaptive thresholding (window size: %d)\n', local_window_size);
    
    for f = 1:length(freq_indices)
        coherence_slice = multi_scale_coherence(:,:,f);
        
        % Pad for edge handling
        padded_coherence = padarray(coherence_slice, [local_window_size local_window_size], 'replicate');
        
        for i = 1:nx
            for j = 1:ny
                % Extract local window
                local_window = padded_coherence(i:i+2*local_window_size, j:j+2*local_window_size);
                
                % Calculate robust statistics (median/MAD more robust than mean/std)
                local_median = median(local_window(:));
                local_mad = median(abs(local_window(:) - local_median));
                
                % Set adaptive threshold
                adaptive_threshold = local_median + coherence_sensitivity * 1.4826 * local_mad;
                
                % Create mask
                standing_wave_mask_adaptive(i,j,f) = coherence_slice(i,j) > adaptive_threshold;
            end
        end
    end
else
    % Fall back to global percentile
    for f = 1:length(freq_indices)
        threshold = prctile(multi_scale_coherence(:,:,f), 85);
        standing_wave_mask_adaptive(:,:,f) = multi_scale_coherence(:,:,f) > threshold;
    end
end

%% ============================================================================
%% FIND DOMINANT STANDING WAVE CHARACTERISTICS
%% ============================================================================

fprintf('\n=== IDENTIFYING STANDING WAVE CHARACTERISTICS ===\n');

% Analyze frequency content with coherence weighting
avg_amplitude = squeeze(mean(mean(Amplitude_Data, 1), 2));
avg_coherence = squeeze(mean(mean(multi_scale_coherence, 1), 2));

% Weight amplitude by coherence to find standing wave frequencies
weighted_spectrum = avg_amplitude .* avg_coherence;
[~, dominant_freq_idx] = max(weighted_spectrum);
dominant_freq_val = freq_axis(freq_indices(dominant_freq_idx));

% Find spatial wavelength of standing wave
dominant_phase = Phase_Data(:,:,dominant_freq_idx);
[phase_grad_x, phase_grad_y] = gradient(dominant_phase);

% Calculate average spatial wavelength
avg_grad_x = mean(abs(phase_grad_x(:)));
avg_grad_y = mean(abs(phase_grad_y(:)));
spatial_wavelength_x = 2*pi / avg_grad_x;
spatial_wavelength_y = 2*pi / avg_grad_y;

fprintf('Dominant standing wave frequency: %.2f MHz\n', dominant_freq_val/1e6);
fprintf('Spatial wavelengths: X=%.2f mm, Y=%.2f mm\n', spatial_wavelength_x, spatial_wavelength_y);
fprintf('Standing wave detection: %.1f%% of pixel-frequencies\n', ...
    100*sum(standing_wave_mask_adaptive(:))/numel(standing_wave_mask_adaptive));

%% ============================================================================
%% COMPREHENSIVE FILTERING
%% ============================================================================

fprintf('\n=== APPLYING COMPREHENSIVE FILTERING ===\n');

Data_comprehensive_filt = zeros(size(Data));

% Apply frequency-domain filtering with smooth transitions
tic;
fprintf('Applying adaptive frequency-domain filtering...\n');

for i = 1:nx
    if mod(i,10) == 0
        fprintf('  Progress: %d/%d (%.1fs elapsed)\n', i, nx, toc);
    end
    for j = 1:ny
        signal = squeeze(Data(i,j,:));
        fft_signal = fft(signal, nfft);
        
        % Apply smooth suppression instead of hard cutoff
        for f = 1:length(freq_indices)
            freq_idx = freq_indices(f);
            
            if standing_wave_mask_adaptive(i,j,f)
                % Calculate suppression factor based on coherence strength
                coherence_strength = multi_scale_coherence(i,j,f);
                max_coherence = max(multi_scale_coherence(:));
                
                % Smooth suppression: stronger coherence = stronger suppression
                suppression = phase_reduction_factor + ...
                    (1 - phase_reduction_factor) * (1 - coherence_strength/max_coherence);
                
                % Apply suppression
                fft_signal(freq_idx) = fft_signal(freq_idx) * suppression;
                
                % Handle conjugate symmetry
                if freq_idx > 1 && freq_idx <= nfft/2
                    conj_idx = nfft - freq_idx + 2;
                    fft_signal(conj_idx) = fft_signal(conj_idx) * suppression;
                end
            end
        end
        
        % Reconstruct with proper windowing compensation
        filtered_signal = real(ifft(fft_signal));
        Data_comprehensive_filt(i,j,:) = filtered_signal(1:nt) ./ window;
    end
end
fprintf('Comprehensive filtering completed in %.1f seconds\n', toc);

%% ============================================================================
%% TEMPORAL STANDING WAVE ANALYSIS FOR VERIFICATION
%% ============================================================================

fprintf('\n=== PERFORMING TEMPORAL VERIFICATION ANALYSIS ===\n');

% Initialize temporal analysis arrays
n_frames = nt;
sw_score_original = zeros(n_frames, 1);
sw_score_filtered = zeros(n_frames, 1);
spatial_periodicity_original = zeros(n_frames, 1);
spatial_periodicity_filtered = zeros(n_frames, 1);

% Analyze each time frame
fprintf('Analyzing %d time frames...\n', n_frames);
tic;

for t_idx = 1:n_frames
    if mod(t_idx, 100) == 0
        fprintf('  Frame %d/%d (%.1fs elapsed)\n', t_idx, n_frames, toc);
    end
    
    % Extract spatial slices
    slice_original = Data(:,:,t_idx);
    slice_filtered = Data_comprehensive_filt(:,:,t_idx);
    
    % Skip low-energy frames
    if max(abs(slice_original(:))) < 1e-6
        continue;
    end
    
    % Compute 2D spatial FFT
    fft2_original = fft2(slice_original);
    fft2_filtered = fft2(slice_filtered);
    
    % Calculate power spectra
    power_original = abs(fftshift(fft2_original)).^2;
    power_filtered = abs(fftshift(fft2_filtered)).^2;
    
    % Remove DC component
    center_x = round(nx/2) + 1;
    center_y = round(ny/2) + 1;
    power_original(center_x, center_y) = 0;
    power_filtered(center_x, center_y) = 0;
    
    % Calculate concentration metric (standing wave indicator)
    sorted_power_orig = sort(power_original(:), 'descend');
    sorted_power_filt = sort(power_filtered(:), 'descend');
    
    % Top 10 peaks concentration
    n_peaks = 10;
    if length(sorted_power_orig) >= n_peaks
        sw_score_original(t_idx) = sum(sorted_power_orig(1:n_peaks)) / sum(sorted_power_orig);
        sw_score_filtered(t_idx) = sum(sorted_power_filt(1:n_peaks)) / sum(sorted_power_filt);
    end
    
    % Calculate spatial periodicity using autocorrelation
    spatial_periodicity_original(t_idx) = calculate_enhanced_periodicity(slice_original);
    spatial_periodicity_filtered(t_idx) = calculate_enhanced_periodicity(slice_filtered);
end

fprintf('Temporal analysis completed in %.1f seconds\n', toc);

%% ============================================================================
%% COMPREHENSIVE VERIFICATION METRICS
%% ============================================================================

fprintf('\n=== COMPUTING COMPREHENSIVE VERIFICATION METRICS ===\n');

% 1. Time-domain energy distribution
energy_original = squeeze(sum(sum(abs(Data).^2, 1), 2));
energy_filtered = squeeze(sum(sum(abs(Data_comprehensive_filt).^2, 1), 2));
energy_ratio = energy_filtered ./ (energy_original + 1e-10);

% 2. Frequency domain concentration
freq_concentration_orig = mean(sw_score_original(sw_score_original > 0));
freq_concentration_filt = mean(sw_score_filtered(sw_score_filtered > 0));
concentration_reduction = 100 * (freq_concentration_orig - freq_concentration_filt) / freq_concentration_orig;

% 3. Spatial correlation analysis
spatial_corr_orig = calculate_spatial_correlation_map(Data);
spatial_corr_filt = calculate_spatial_correlation_map(Data_comprehensive_filt);
correlation_reduction = 100 * (mean(spatial_corr_orig(:)) - mean(spatial_corr_filt(:))) / mean(spatial_corr_orig(:));

% 4. Phase stability analysis
phase_stability_orig = calculate_phase_stability(Data, fs);
phase_stability_filt = calculate_phase_stability(Data_comprehensive_filt, fs);
stability_reduction = 100 * (mean(phase_stability_orig(:)) - mean(phase_stability_filt(:))) / mean(phase_stability_orig(:));

fprintf('\nVERIFICATION METRICS:\n');
fprintf('1. Frequency Concentration Reduction: %.1f%%\n', concentration_reduction);
fprintf('2. Spatial Correlation Reduction: %.1f%%\n', correlation_reduction);
fprintf('3. Phase Stability Reduction: %.1f%%\n', stability_reduction);
fprintf('4. Energy Preservation: %.1f%% ± %.1f%%\n', mean(energy_ratio)*100, std(energy_ratio)*100);

%% ============================================================================
%% VISUALIZATION: COMPREHENSIVE VERIFICATION
%% ============================================================================

% Figure 1: Temporal Standing Wave Analysis
figure('Name', 'Temporal Standing Wave Verification', 'Position', [50, 50, 1400, 900]);

subplot(3,2,1);
plot(t, sw_score_original, 'b-', 'LineWidth', 1.5);
hold on;
plot(t, sw_score_filtered, 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('SW Score');
title('Standing Wave Score Over Time');
legend('Original', 'Filtered', 'Location', 'best');
grid on;

subplot(3,2,2);
plot(t, spatial_periodicity_original, 'b-', 'LineWidth', 1.5);
hold on;
plot(t, spatial_periodicity_filtered, 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Periodicity');
title('Spatial Periodicity Over Time');
legend('Original', 'Filtered', 'Location', 'best');
grid on;

subplot(3,2,3);
removal_effectiveness = 100 * (sw_score_original - sw_score_filtered) ./ (sw_score_original + 1e-6);
plot(t, removal_effectiveness, 'g-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Removal (%)');
title('Standing Wave Removal Effectiveness');
ylim([0 100]);
grid on;

subplot(3,2,4);
plot(t, energy_ratio, 'k-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Energy Ratio');
title('Energy Preservation (Filtered/Original)');
ylim([0.8 1.2]);
grid on;

subplot(3,2,5);
histogram(sw_score_original(sw_score_original > 0), 50, 'FaceColor', 'b', 'FaceAlpha', 0.5);
hold on;
histogram(sw_score_filtered(sw_score_filtered > 0), 50, 'FaceColor', 'r', 'FaceAlpha', 0.5);
xlabel('SW Score'); ylabel('Count');
title('Distribution of Standing Wave Scores');
legend('Original', 'Filtered');

subplot(3,2,6);
scatter(sw_score_original, sw_score_filtered, 10, 'filled');
hold on;
plot([0 max(sw_score_original)], [0 max(sw_score_original)], 'r--', 'LineWidth', 1);
xlabel('Original SW Score'); ylabel('Filtered SW Score');
title('Score Correlation (Below Line = Improvement)');
grid on;

% Figure 2: Spatial Analysis
figure('Name', 'Spatial Standing Wave Verification', 'Position', [100, 100, 1400, 800]);

% Select frame with strong standing wave
[~, max_sw_frame] = max(sw_score_original);

subplot(2,3,1);
imagesc(x, y, Data(:,:,max_sw_frame).');
title(sprintf('Original at t=%.1f μs', t(max_sw_frame)));
xlabel('X'); ylabel('Y');
colorbar; axis equal tight;

subplot(2,3,2);
imagesc(x, y, Data_comprehensive_filt(:,:,max_sw_frame).');
title('Filtered');
xlabel('X'); ylabel('Y');
colorbar; axis equal tight;

subplot(2,3,3);
diff_image = Data(:,:,max_sw_frame) - Data_comprehensive_filt(:,:,max_sw_frame);
imagesc(x, y, diff_image.');
title('Removed Component');
xlabel('X'); ylabel('Y');
colorbar; axis equal tight;

subplot(2,3,4);
fft2_orig = fftshift(abs(fft2(Data(:,:,max_sw_frame))));
imagesc(log10(fft2_orig + 1e-6));
title('Original |FFT|');
colorbar; axis equal tight;

subplot(2,3,5);
fft2_filt = fftshift(abs(fft2(Data_comprehensive_filt(:,:,max_sw_frame))));
imagesc(log10(fft2_filt + 1e-6));
title('Filtered |FFT|');
colorbar; axis equal tight;

subplot(2,3,6);
imagesc(log10(abs(fft2_orig - fft2_filt) + 1e-6));
title('|FFT| Difference');
colorbar; axis equal tight;

% Figure 3: A-scan and B-scan Comparison
figure('Name', 'A-scan and B-scan Verification', 'Position', [150, 150, 1200, 800]);

subplot(2,2,1);
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_comprehensive_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title(sprintf('A-scan at (%d,%d)', defect_x, defect_y));
legend('Original', 'Filtered', 'Location', 'best');
grid on;

subplot(2,2,2);
original_fft = abs(fft(squeeze(Data(defect_x, defect_y, :))));
filtered_fft = abs(fft(squeeze(Data_comprehensive_filt(defect_x, defect_y, :))));
freq_axis_plot = (0:length(original_fft)-1) * fs / length(original_fft) / 1e6;
plot(freq_axis_plot(1:round(end/2)), original_fft(1:round(end/2)), 'b-', 'LineWidth', 1.5);
hold on;
plot(freq_axis_plot(1:round(end/2)), filtered_fft(1:round(end/2)), 'r-', 'LineWidth', 1.5);
xlabel('Frequency (MHz)'); ylabel('Magnitude');
title('Frequency Spectrum');
legend('Original', 'Filtered');
xlim([0 10]);
grid on;

subplot(2,2,3);
imagesc(x, t, squeeze(Data(:, defect_y, :)).');
title(sprintf('Original B-scan at Y=%d', defect_y));
xlabel('X position'); ylabel('Time (μs)');
colorbar; caxis([-1 1]*max(abs(Data(:)))*0.5);

subplot(2,2,4);
imagesc(x, t, squeeze(Data_comprehensive_filt(:, defect_y, :)).');
title('Filtered B-scan');
xlabel('X position'); ylabel('Time (μs)');
colorbar; caxis([-1 1]*max(abs(Data(:)))*0.5);

% Figure 4: Advanced Verification - Autocorrelation
figure('Name', 'Autocorrelation Verification', 'Position', [200, 200, 1200, 600]);

% Compute 2D autocorrelation for a representative time slice
time_slice = round(nt/2);
autocorr_orig = xcorr2(Data(:,:,time_slice) - mean(mean(Data(:,:,time_slice))));
autocorr_filt = xcorr2(Data_comprehensive_filt(:,:,time_slice) - mean(mean(Data_comprehensive_filt(:,:,time_slice))));

% Normalize
autocorr_orig = autocorr_orig / max(autocorr_orig(:));
autocorr_filt = autocorr_filt / max(autocorr_filt(:));

% Extract central region
center = size(autocorr_orig)/2;
range = 30;

subplot(1,3,1);
imagesc(autocorr_orig(center(1)-range:center(1)+range, center(2)-range:center(2)+range));
title('Original Autocorrelation');
colorbar; axis equal tight;

subplot(1,3,2);
imagesc(autocorr_filt(center(1)-range:center(1)+range, center(2)-range:center(2)+range));
title('Filtered Autocorrelation');
colorbar; axis equal tight;

subplot(1,3,3);
% Radial average
[X, Y] = meshgrid(-range:range, -range:range);
R = sqrt(X.^2 + Y.^2);
radial_bins = 0:range;
radial_orig = zeros(size(radial_bins));
radial_filt = zeros(size(radial_bins));

for r = 1:length(radial_bins)-1
    mask = (R >= radial_bins(r)) & (R < radial_bins(r+1));
    region_orig = autocorr_orig(center(1)-range:center(1)+range, center(2)-range:center(2)+range);
    region_filt = autocorr_filt(center(1)-range:center(1)+range, center(2)-range:center(2)+range);
    radial_orig(r) = mean(region_orig(mask));
    radial_filt(r) = mean(region_filt(mask));
end

plot(radial_bins, radial_orig, 'b-', 'LineWidth', 2);
hold on;
plot(radial_bins, radial_filt, 'r-', 'LineWidth', 2);
xlabel('Lag Distance'); ylabel('Correlation');
title('Radial Autocorrelation Profile');
legend('Original', 'Filtered');
grid on;

%% ============================================================================
%% FINAL SUMMARY AND RECOMMENDATIONS
%% ============================================================================

fprintf('\n=== COMPREHENSIVE ANALYSIS COMPLETE ===\n');
fprintf('\nSTANDING WAVE REMOVAL SUMMARY:\n');
fprintf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');
fprintf('Dominant Frequency: %.2f MHz\n', dominant_freq_val/1e6);
fprintf('Spatial Wavelengths: X=%.1f mm, Y=%.1f mm\n', spatial_wavelength_x, spatial_wavelength_y);
fprintf('Pixels Affected: %.1f%%\n', 100*sum(standing_wave_mask_adaptive(:))/numel(standing_wave_mask_adaptive));
fprintf('\nREMOVAL EFFECTIVENESS:\n');
fprintf('  • Frequency Concentration: %.1f%% reduction\n', concentration_reduction);
fprintf('  • Spatial Correlation: %.1f%% reduction\n', correlation_reduction);
fprintf('  • Phase Stability: %.1f%% reduction\n', stability_reduction);
fprintf('  • Signal Energy Preserved: %.1f%%\n', mean(energy_ratio)*100);
fprintf('\nQUALITY METRICS:\n');
fprintf('  • Peak SW Score (Original): %.3f\n', max(sw_score_original));
fprintf('  • Peak SW Score (Filtered): %.3f\n', max(sw_score_filtered));
fprintf('  • Average Improvement: %.1f%%\n', mean(removal_effectiveness(removal_effectiveness>0)));
fprintf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');

% Save comprehensive results
standing_wave_analysis = struct();
standing_wave_analysis.dominant_freq = dominant_freq_val;
standing_wave_analysis.spatial_wavelengths = [spatial_wavelength_x, spatial_wavelength_y];
standing_wave_analysis.temporal_scores = struct('original', sw_score_original, 'filtered', sw_score_filtered);
standing_wave_analysis.verification_metrics = struct(...
    'concentration_reduction', concentration_reduction, ...
    'correlation_reduction', correlation_reduction, ...
    'stability_reduction', stability_reduction, ...
    'energy_preservation', mean(energy_ratio)*100);
standing_wave_analysis.mask = standing_wave_mask_adaptive;
standing_wave_analysis.coherence_map = multi_scale_coherence;

fprintf('\nData and analysis saved in variables:\n');
fprintf('  • Data_comprehensive_filt - Filtered ultrasonic data\n');
fprintf('  • standing_wave_analysis - Complete analysis structure\n');

%% ============================================================================
%% HELPER FUNCTIONS
%% ============================================================================

function periodicity = calculate_enhanced_periodicity(slice)
    % Enhanced periodicity calculation using multiple methods
    
    % Method 1: 2D Autocorrelation peaks
    autocorr = xcorr2(slice - mean(slice(:)));
    center_idx = size(autocorr)/2 + 0.5;
    
    % Normalize
    center_val = autocorr(round(center_idx(1)), round(center_idx(2)));
    if abs(center_val) > 1e-6
        autocorr = autocorr / center_val;
    end
    
    % Find peaks away from center
    [X, Y] = meshgrid(1:size(autocorr,2), 1:size(autocorr,1));
    dist_from_center = sqrt((X-center_idx(2)).^2 + (Y-center_idx(1)).^2);
    
    % Mask out center region
    mask = dist_from_center > 5;
    autocorr_masked = abs(autocorr) .* mask;
    
    % Find significant peaks
    peaks = autocorr_masked > 0.3; % 30% of center peak
    periodicity1 = sum(peaks(:)) / numel(peaks);
    
    % Method 2: Frequency domain concentration
    fft2_data = abs(fft2(slice)).^2;
    sorted_power = sort(fft2_data(:), 'descend');
    if length(sorted_power) >= 10
        periodicity2 = sum(sorted_power(2:11)) / sum(sorted_power(2:end)); % Exclude DC
    else
        periodicity2 = 0;
    end
    
    % Combine methods
    periodicity = (periodicity1 + periodicity2) / 2;
end

function corr_map = calculate_spatial_correlation_map(data_3d)
    % Calculate average correlation between adjacent pixels
    [nx, ny, ~] = size(data_3d);
    corr_map = zeros(nx-1, ny-1);
    
    for i = 1:nx-1
        for j = 1:ny-1
            % Get four adjacent pixels
            signal_00 = squeeze(data_3d(i,j,:));
            signal_10 = squeeze(data_3d(i+1,j,:));
            signal_01 = squeeze(data_3d(i,j+1,:));
            
            % Calculate correlations
            if max(abs(signal_00)) > 1e-6
                corr1 = max(xcorr(signal_00, signal_10, 'normalized'));
                corr2 = max(xcorr(signal_00, signal_01, 'normalized'));
                corr_map(i,j) = (corr1 + corr2) / 2;
            end
        end
    end
end

function stability_map = calculate_phase_stability(data_3d, fs)
    % Calculate phase stability using instantaneous frequency variance
    [nx, ny, nt] = size(data_3d);
    stability_map = zeros(nx, ny);
    
    for i = 1:nx
        for j = 1:ny
            signal = squeeze(data_3d(i,j,:));
            
            if max(abs(signal)) > 1e-6
                % Hilbert transform for instantaneous phase
                analytic = hilbert(signal);
                inst_phase = unwrap(angle(analytic));
                
                % Instantaneous frequency
                inst_freq = diff(inst_phase) * fs / (2*pi);
                
                % Stability = inverse of frequency variance
                stability_map(i,j) = 1 / (var(inst_freq) + 1e-6);
            end
        end
    end
end

fprintf('\nScript execution completed successfully!\n');
