%% Ultrasonic Standing Wave Filtering Methods
% Comprehensive collection of methods to filter standing waves from ultrasonic data
% Input: Data (64x64x2020 ultrasonic scan data)
% Supporting variables: x, y, t, toi1, toi2

%% Setup and Parameters
% Assumed parameters - adjust based on your actual setup
fs = 50e6; % Sampling frequency (50 MHz - typical for ultrasonics)
dt = 1/fs; % Time step
f_standing = 5e6; % Standing wave frequency (5 MHz as specified)

% Time indices for C-scan visualization
[~,i1] = min(abs(t-toi1)); % Index for toi1
[~,i2] = min(abs(t-toi2)); % Index for toi2

% Defect location for A-scan comparison (bottom edge where defects are)
defect_x = 32; % Middle x position
defect_y = 60;  % Near bottom edge (adjust based on actual defect location)

% Set colormap
colormap(viridis);

%% Method 1: Background/Reference Subtraction
% Best when you have a reference scan without defects or can estimate background
% Parameter tuning: Adjust ref_region based on known defect-free areas
% Processing: Simple, effective for uniform backgrounds

% Use defect-free region as reference (top 70% of scan to avoid bottom defects)
ref_height = round(0.7 * size(Data,1));
ref_region = Data(1:ref_height, :, :);
background_estimate = mean(ref_region, [1,2]); % Average over spatial dimensions

% Subtract background from all data
Data_bg_sub = Data - background_estimate;

% Plot original C-scans
figure('Name', 'Original C-scans - Method 1');
subplot(1,2,1);
imagesc(x, y, Data(:,:,i1).');
title('Original C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data(:,:,i2).');
title('Original C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% Plot filtered C-scans
figure('Name', 'Background Subtracted C-scans - Method 1');
subplot(1,2,1);
imagesc(x, y, Data_bg_sub(:,:,i1).');
title('Background Subtracted C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_bg_sub(:,:,i2).');
title('Background Subtracted C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 1');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_bg_sub(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location');
legend('Original', 'Background Subtracted', 'Location', 'best');
grid on;

%% Method 2: Temporal Moving Average Subtraction
% Removes slowly varying standing wave components in time domain
% Parameter tuning: Adjust window_size based on standing wave temporal period
% Processing: Good for time-varying standing waves

window_size = 100; % Adjust based on standing wave characteristics (larger = more smoothing)
Data_temporal_filt = zeros(size(Data));

for i = 1:size(Data,1)
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        moving_avg = movmean(signal, window_size);
        Data_temporal_filt(i,j,:) = signal - moving_avg;
    end
end

% Plot filtered C-scans
figure('Name', 'Temporal Moving Average Filtered C-scans - Method 2');
subplot(1,2,1);
imagesc(x, y, Data_temporal_filt(:,:,i1).');
title('Temporal Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_temporal_filt(:,:,i2).');
title('Temporal Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 2');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_temporal_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - Temporal Filtering');
legend('Original', 'Temporal Filtered', 'Location', 'best');
grid on;

%% Method 3: Spatial Median Filtering
% Removes spatially coherent standing wave patterns
% Parameter tuning: Can use mean instead of median, or weighted spatial averaging
% Processing: Removes spatially coherent patterns

Data_spatial_filt = zeros(size(Data));
for k = 1:size(Data,3)
    spatial_median = median(Data(:,:,k), [1,2]);
    Data_spatial_filt(:,:,k) = Data(:,:,k) - spatial_median;
end

% Plot filtered C-scans
figure('Name', 'Spatial Median Filtered C-scans - Method 3');
subplot(1,2,1);
imagesc(x, y, Data_spatial_filt(:,:,i1).');
title('Spatial Median Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_spatial_filt(:,:,i2).');
title('Spatial Median Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 3');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_spatial_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - Spatial Filtering');
legend('Original', 'Spatial Filtered', 'Location', 'best');
grid on;

%% Method 4: Frequency Domain Filtering
% Target specific standing wave frequencies with bandstop filter
% Parameter tuning: Adjust f_notch_range based on actual standing wave frequencies
% Processing: Precise frequency targeting

% Design bandstop filter around standing wave frequency
f_notch_range = [f_standing-0.5e6, f_standing+0.5e6]; % ±0.5 MHz around 5 MHz
nyquist_freq = fs/2;
[b, a] = butter(4, f_notch_range/nyquist_freq, 'stop');

Data_freq_filt = zeros(size(Data));
for i = 1:size(Data,1)
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        Data_freq_filt(i,j,:) = filtfilt(b, a, signal);
    end
end

% Plot filtered C-scans
figure('Name', 'Frequency Domain Filtered C-scans - Method 4');
subplot(1,2,1);
imagesc(x, y, Data_freq_filt(:,:,i1).');
title('Frequency Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_freq_filt(:,:,i2).');
title('Frequency Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 4');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_freq_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - Frequency Filtering');
legend('Original', 'Frequency Filtered', 'Location', 'best');
grid on;

%% Method 5: Principal Component Analysis (PCA)
% Remove dominant standing wave modes (computationally intensive)
% Parameter tuning: Adjust num_components_to_remove based on eigenvalue analysis
% Processing: Powerful but computationally intensive

% Reshape data for PCA
[nx, ny, nt] = size(Data);
Data_reshaped = reshape(Data, nx*ny, nt);

% Perform PCA
[coeff, score, latent] = pca(Data_reshaped');

% Remove first few components (likely standing waves)
num_components_to_remove = 3; % Adjust based on eigenvalue analysis
score_pca_filt = score;
score_pca_filt(:, 1:num_components_to_remove) = 0;

% Reconstruct filtered data
Data_pca_filt_reshaped = (score_pca_filt * coeff')';
Data_pca_filt = reshape(Data_pca_filt_reshaped, nx, ny, nt);

% Plot PCA eigenvalues for tuning
figure('Name', 'PCA Eigenvalue Analysis - Method 5');
semilogy(latent(1:20), 'bo-');
xlabel('Principal Component'); ylabel('Eigenvalue');
title('PCA Eigenvalues (First 20 Components)');
grid on;

% Plot filtered C-scans
figure('Name', 'PCA Filtered C-scans - Method 5');
subplot(1,2,1);
imagesc(x, y, Data_pca_filt(:,:,i1).');
title('PCA Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_pca_filt(:,:,i2).');
title('PCA Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 5');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_pca_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - PCA Filtering');
legend('Original', 'PCA Filtered', 'Location', 'best');
grid on;

%% Method 6: Adaptive Filtering with Defect-Free Reference
% Use defect-free regions to estimate standing wave pattern
% Parameter tuning: Adjust defect_free_region based on known defect locations
% Processing: Uses defect-free regions as reference

% Define defect-free regions (avoid bottom edge where defects are)
defect_free_height = round(0.8 * size(Data,1)); % Top 80% of scan
Data_adaptive_filt = zeros(size(Data));

for k = 1:size(Data,3)
    slice = Data(:,:,k);
    % Use defect-free region as reference
    ref_region = slice(1:defect_free_height, :);
    background = mean(ref_region(:));
    Data_adaptive_filt(:,:,k) = slice - background;
end

% Plot filtered C-scans
figure('Name', 'Adaptive Filtered C-scans - Method 6');
subplot(1,2,1);
imagesc(x, y, Data_adaptive_filt(:,:,i1).');
title('Adaptive Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_adaptive_filt(:,:,i2).');
title('Adaptive Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 6');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_adaptive_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - Adaptive Filtering');
legend('Original', 'Adaptive Filtered', 'Location', 'best');
grid on;

%% Method 7: Discrete Wavelet Transform (DWT) Denoising
% Treat standing waves as noise to be removed
% Parameter tuning: wavelet type, decomposition levels, thresholding method
% Processing: Automatic noise reduction

Data_dwt_filt = zeros(size(Data));
wavelet_name = 'db8'; % Daubechies 8 - good for ultrasonic signals
levels = 6; % Decomposition levels

for i = 1:size(Data,1)
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Wavelet denoising with Bayesian method
        Data_dwt_filt(i,j,:) = wdenoise(signal, levels, ...
            'Wavelet', wavelet_name, ...
            'DenoisingMethod', 'Bayes', ...
            'ThresholdRule', 'Soft', ...
            'NoiseVariance', 'estimate');
    end
end

% Plot filtered C-scans
figure('Name', 'DWT Denoised C-scans - Method 7');
subplot(1,2,1);
imagesc(x, y, Data_dwt_filt(:,:,i1).');
title('DWT Denoised C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_dwt_filt(:,:,i2).');
title('DWT Denoised C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 7');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_dwt_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - DWT Denoising');
legend('Original', 'DWT Denoised', 'Location', 'best');
grid on;

%% Method 8: Frequency Band Filtering with DWT
% Remove specific frequency bands containing standing waves
% Parameter tuning: which detail levels to zero out, wavelet type
% Processing: Selective frequency removal

Data_dwt_band_filt = zeros(size(Data));
wavelet_name = 'db8';
levels = 6;

for i = 1:size(Data,1)
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Decompose signal
        [c, l] = wavedec(signal, levels, wavelet_name);
        
        % Zero out specific detail coefficients (standing wave frequencies)
        coeffs_to_zero = [3, 4]; % Adjust based on frequency analysis
        
        for level = coeffs_to_zero
            % Get indices for this detail level
            d_start = sum(l(1:end-level)) + 1;
            d_end = sum(l(1:end-level+1));
            c(d_start:d_end) = 0; % Zero out these coefficients
        end
        
        % Reconstruct signal
        Data_dwt_band_filt(i,j,:) = waverec(c, l, wavelet_name);
    end
end

% Plot filtered C-scans
figure('Name', 'DWT Band Filtered C-scans - Method 8');
subplot(1,2,1);
imagesc(x, y, Data_dwt_band_filt(:,:,i1).');
title('DWT Band Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_dwt_band_filt(:,:,i2).');
title('DWT Band Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 8');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_dwt_band_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - DWT Band Filtering');
legend('Original', 'DWT Band Filtered', 'Location', 'best');
grid on;

%% Method 9: Continuous Wavelet Transform (CWT) Analysis
% Analyze time-frequency content to identify and filter standing waves
% Parameter tuning: frequency range, wavelet type for CWT
% Processing: Time-frequency domain insight

% Analyze one representative signal first
sample_signal = squeeze(Data(defect_x, defect_y, :));

% Perform CWT
freq_range = [1e6, 10e6]; % 1-10 MHz frequency range
[wt, f_cwt] = cwt(sample_signal, 'amor', fs, 'FrequencyLimits', freq_range);

% Visualize time-frequency content
figure('Name', 'CWT Time-Frequency Analysis - Method 9');
imagesc(t, f_cwt/1e6, abs(wt));
set(gca, 'YDir', 'normal');
xlabel('Time (μs)'); ylabel('Frequency (MHz)');
title('CWT of Sample Signal at Defect Location');
colorbar;

% Filter based on CWT (simplified approach - zero out standing wave frequencies)
Data_cwt_filt = zeros(size(Data));
for i = 1:size(Data,1)
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Apply bandstop filter based on CWT analysis
        [wt_temp, f_temp] = cwt(signal, 'amor', fs, 'FrequencyLimits', freq_range);
        
        % Zero out frequencies around standing wave (simplified filtering)
        standing_freq_idx = find(abs(f_temp - f_standing) < 0.5e6);
        wt_temp(standing_freq_idx, :) = 0;
        
        % Reconstruct (simplified - using ifft approach)
        % Note: This is a simplified reconstruction; proper CWT inversion is more complex
        Data_cwt_filt(i,j,:) = real(sum(wt_temp, 1))';
    end
end

% Normalize reconstructed data
Data_cwt_filt = Data_cwt_filt / max(abs(Data_cwt_filt(:))) * max(abs(Data(:)));

% Plot filtered C-scans
figure('Name', 'CWT Filtered C-scans - Method 9');
subplot(1,2,1);
imagesc(x, y, Data_cwt_filt(:,:,i1).');
title('CWT Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_cwt_filt(:,:,i2).');
title('CWT Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

%% Method 10: 2D Wavelet Transform for Spatial Patterns
% Remove spatially coherent standing wave patterns using 2D wavelets
% Parameter tuning: decomposition levels, which coefficients to modify
% Processing: Spatial pattern removal

Data_2d_wavelet_filt = zeros(size(Data));
wavelet_name = 'db4'; % Shorter wavelet for 2D processing

for k = 1:size(Data,3)
    % Apply 2D wavelet transform to spatial slice
    slice = Data(:,:,k);
    
    % 2D wavelet decomposition
    [c, s] = wavedec2(slice, 3, wavelet_name);
    
    % Get approximation coefficients (low frequency spatial content)
    cA = appcoef2(c, s, wavelet_name, 3);
    
    % Zero out approximation coefficients to remove large-scale patterns
    cA = zeros(size(cA));
    
    % Reconstruct with modified coefficients
    c_new = c;
    c_new(1:numel(cA)) = cA(:);
    
    Data_2d_wavelet_filt(:,:,k) = waverec2(c_new, s, wavelet_name);
end

% Plot filtered C-scans
figure('Name', '2D Wavelet Filtered C-scans - Method 10');
subplot(1,2,1);
imagesc(x, y, Data_2d_wavelet_filt(:,:,i1).');
title('2D Wavelet Filtered C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_2d_wavelet_filt(:,:,i2).');
title('2D Wavelet Filtered C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 10');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_2d_wavelet_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - 2D Wavelet Filtering');
legend('Original', '2D Wavelet Filtered', 'Location', 'best');
grid on;

%% Method 11: Adaptive Wavelet Thresholding
% Automatically determine thresholds based on signal statistics
% Parameter tuning: threshold calculation method, wavelet type
% Processing: Automatic threshold selection

Data_adaptive_wavelet_filt = zeros(size(Data));

for i = 1:size(Data,1)
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Wavelet decomposition
        [c, l] = wavedec(signal, 6, 'db8');
        
        % Estimate noise level from finest detail coefficients
        sigma = median(abs(c(1:l(1))))/0.6745;
        
        % Calculate adaptive threshold (Donoho & Johnstone method)
        n = length(signal);
        threshold = sigma * sqrt(2*log(n));
        
        % Apply soft thresholding
        c_thresh = wthresh(c, 's', threshold);
        
        % Reconstruct
        Data_adaptive_wavelet_filt(i,j,:) = waverec(c_thresh, l, 'db8');
    end
end

% Plot filtered C-scans
figure('Name', 'Adaptive Wavelet Thresholded C-scans - Method 11');
subplot(1,2,1);
imagesc(x, y, Data_adaptive_wavelet_filt(:,:,i1).');
title('Adaptive Wavelet Thresholded C-scan at toi1');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

subplot(1,2,2);
imagesc(x, y, Data_adaptive_wavelet_filt(:,:,i2).');
title('Adaptive Wavelet Thresholded C-scan at toi2');
xlabel('X position'); ylabel('Y position');
colorbar; axis equal tight;

% A-scan comparison
figure('Name', 'A-scan Comparison - Method 11');
plot(t, squeeze(Data(defect_x, defect_y, :)), 'b-', 'LineWidth', 1.5);
hold on;
plot(t, squeeze(Data_adaptive_wavelet_filt(defect_x, defect_y, :)), 'r-', 'LineWidth', 1.5);
xlabel('Time (μs)'); ylabel('Amplitude');
title('A-scan at Defect Location - Adaptive Wavelet Thresholding');
legend('Original', 'Adaptive Wavelet Filtered', 'Location', 'best');
grid on;

%% Summary and Recommendations
% === FILTERING METHOD SUMMARY ===
% Method 1: Background Subtraction - Simple, effective for uniform backgrounds
% Method 2: Temporal Moving Average - Good for time-varying standing waves
% Method 3: Spatial Median - Removes spatially coherent patterns
% Method 4: Frequency Domain - Precise frequency targeting
% Method 5: PCA - Powerful but computationally intensive
% Method 6: Adaptive - Uses defect-free regions as reference
% Method 7: DWT Denoising - Automatic noise reduction
% Method 8: DWT Band Filtering - Selective frequency removal
% Method 9: CWT Analysis - Time-frequency domain insight
% Method 10: 2D Wavelet - Spatial pattern removal
% Method 11: Adaptive Wavelet - Automatic threshold selection
%
% Recommended starting methods: 1, 6, 7, 11
% For frequency-specific filtering: 4, 8
% For spatial pattern analysis: 3, 5, 10

%% Parameter Tuning Guidelines
% === PARAMETER TUNING GUIDELINES ===
% 1. Background Subtraction: Adjust ref_height based on defect locations
% 2. Temporal Moving Average: window_size = 50-200 samples typically
% 3. Spatial Median: Consider using weighted averages for non-uniform arrays
% 4. Frequency Filtering: Set f_notch_range ±10% around standing wave frequency
% 5. PCA: Remove 2-5 components typically; analyze eigenvalue plot
% 6. Adaptive: Define defect_free_region carefully
% 7. DWT Denoising: Try db4, db8, coif4 wavelets; 4-8 decomposition levels
% 8. DWT Band Filtering: Zero levels 3-5 for typical 5MHz standing waves
% 9. CWT: Use "amor" or "morse" wavelets; adjust frequency range
% 10. 2D Wavelet: Use shorter wavelets (db2-db4) for spatial processing
% 11. Adaptive Wavelet: Threshold = sigma*sqrt(2*log(N)) is standard