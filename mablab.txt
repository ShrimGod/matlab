%% Ultrasonic Standing Wave Filtering Methods - USING YOUR PLOTTING FUNCTIONS
% Comprehensive collection of methods to filter standing waves from ultrasonic data
% Input: Data (64x64x2020 ultrasonic scan data)
% Supporting variables: x, y, t

%% Setup and Parameters
% Assumed parameters - adjust based on your actual setup
fs = 50e6; % Sampling frequency (50 MHz - typical for ultrasonics)
dt = 1/fs; % Time step
f_standing = 5e6; % Standing wave frequency (5 MHz as specified)

% Time indices for C-scan visualization (define toi1, toi2)
toi1 = 120; % microseconds - adjust based on your data
toi2 = 124; % microseconds - adjust based on your data

% VERIFICATION: Calculate time indices correctly
[~,i1] = min(abs(t-toi1)); % Index for toi1
[~,i2] = min(abs(t-toi2)); % Index for toi2

% Verify the time indices found the right values
actual_toi1 = t(i1);
actual_toi2 = t(i2);
fprintf('Requested toi1: %.2f μs, Found: %.2f μs (index %d)\n', toi1, actual_toi1, i1);
fprintf('Requested toi2: %.2f μs, Found: %.2f μs (index %d)\n', toi2, actual_toi2, i2);

% Defect location for A-scan comparison (bottom edge where defects are)
defect_x = 32; % Middle x position
defect_y = 60;  % Near bottom edge (adjust based on actual defect location)

% C-scan plotting parameters
gateopt = 1;        % 1 = amplitude, 2 = time-of-flight
th_gate = 0.01;     % amplitude threshold (adjust based on your data)
gateside = 1;       % 1 = max, 2 = min, other = abs max

% Set colormap (fixed)
colormap(parula);

fprintf('Starting ultrasonic standing wave filtering analysis...\n');
fprintf('Data dimensions: %dx%dx%d\n', size(Data,1), size(Data,2), size(Data,3));

% VERIFICATION: Check data array structure
[nx, ny, nt] = size(Data);
fprintf('nx (x-positions): %d, ny (y-positions): %d, nt (time samples): %d\n', nx, ny, nt);
fprintf('x range: %.2f to %.2f, y range: %.2f to %.2f\n', min(x), max(x), min(y), max(y));
fprintf('Time range: %.2f to %.2f μs\n', min(t), max(t));

%% Plot Original Data for Reference
fprintf('\n=== PLOTTING ORIGINAL DATA ===\n');
fprintf('Plotting original A-scan at position (%d,%d)...\n', defect_x, defect_y);
plotAscan(t, Data, defect_x, defect_y);
title(sprintf('Original A-scan at Position (%d,%d)', defect_x, defect_y));

fprintf('Plotting original B-scans...\n');
plotBscan(t, Data, 1, x, y, defect_y); % B-scan along x-axis at y=defect_y
title(sprintf('Original B-scan (X-axis) at Y=%d', defect_y));

plotBscan(t, Data, 2, x, y, defect_x); % B-scan along y-axis at x=defect_x  
title(sprintf('Original B-scan (Y-axis) at X=%d', defect_x));

fprintf('Plotting original C-scans...\n');
plotCscan(x, y, t, Data, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Original C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Original C-scan at toi2 = %.2f μs', actual_toi2));

%% Method 1: Background/Reference Subtraction
fprintf('\n=== Method 1: Background/Reference Subtraction ===\n');

% Use defect-free region as reference (top 70% of scan to avoid bottom defects)
ref_height = round(0.7 * size(Data,1));
ref_region = Data(1:ref_height, :, :);
background_estimate = mean(ref_region, [1,2]); % Average over spatial dimensions

% Subtract background from all data
Data_bg_sub = Data - background_estimate;

% Plot results using your functions
fprintf('Plotting Method 1 results...\n');
plotCscan(x, y, t, Data_bg_sub, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 1: Background Subtracted C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_bg_sub, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 1: Background Subtracted C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_bg_sub, defect_x, defect_y);
title(sprintf('Method 1: Background Subtracted A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 2: Temporal Moving Average Subtraction
fprintf('\n=== Method 2: Temporal Moving Average Subtraction ===\n');

window_size = 100; % Adjust based on standing wave characteristics
Data_temporal_filt = zeros(size(Data));

% More efficient processing
fprintf('Processing temporal filtering...\n');
for i = 1:size(Data,1)
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, size(Data,1)); end
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        moving_avg = movmean(signal, window_size);
        Data_temporal_filt(i,j,:) = signal - moving_avg;
    end
end

% Plot results using your functions
fprintf('Plotting Method 2 results...\n');
plotCscan(x, y, t, Data_temporal_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 2: Temporal Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_temporal_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 2: Temporal Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_temporal_filt, defect_x, defect_y);
title(sprintf('Method 2: Temporal Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 3: Spatial Median Filtering
fprintf('\n=== Method 3: Spatial Median Filtering ===\n');

Data_spatial_filt = zeros(size(Data));
for k = 1:size(Data,3)
    if mod(k,200) == 0, fprintf('Progress: %d/%d\n', k, size(Data,3)); end
    spatial_median = median(Data(:,:,k), [1,2]);
    Data_spatial_filt(:,:,k) = Data(:,:,k) - spatial_median;
end

% Plot results using your functions
fprintf('Plotting Method 3 results...\n');
plotCscan(x, y, t, Data_spatial_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 3: Spatial Median Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_spatial_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 3: Spatial Median Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_spatial_filt, defect_x, defect_y);
title(sprintf('Method 3: Spatial Median Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 4: Frequency Domain Filtering
fprintf('\n=== Method 4: Frequency Domain Filtering ===\n');

% Design bandstop filter around standing wave frequency
f_notch_range = [f_standing-0.5e6, f_standing+0.5e6]; % ±0.5 MHz around 5 MHz
nyquist_freq = fs/2;
[b, a] = butter(4, f_notch_range/nyquist_freq, 'stop');

Data_freq_filt = zeros(size(Data));
fprintf('Processing frequency filtering...\n');
for i = 1:size(Data,1)
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, size(Data,1)); end
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        Data_freq_filt(i,j,:) = filtfilt(b, a, signal);
    end
end

% Plot results using your functions
fprintf('Plotting Method 4 results...\n');
plotCscan(x, y, t, Data_freq_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 4: Frequency Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_freq_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 4: Frequency Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_freq_filt, defect_x, defect_y);
title(sprintf('Method 4: Frequency Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 5: Principal Component Analysis (PCA)
fprintf('\n=== Method 5: Principal Component Analysis (PCA) ===\n');

% Reshape data for PCA
Data_reshaped = reshape(Data, nx*ny, nt);

% Perform PCA
fprintf('Computing PCA (this may take a moment)...\n');
[coeff, score, latent] = pca(Data_reshaped');

% Remove first few components (likely standing waves)
num_components_to_remove = 3; % Adjust based on eigenvalue analysis
score_pca_filt = score;
score_pca_filt(:, 1:num_components_to_remove) = 0;

% Reconstruct filtered data
Data_pca_filt_reshaped = (score_pca_filt * coeff')';
Data_pca_filt = reshape(Data_pca_filt_reshaped, nx, ny, nt);

% Plot PCA eigenvalues for tuning
figure('Name', 'PCA Eigenvalue Analysis - Method 5');
semilogy(latent(1:min(20,length(latent))), 'bo-');
xlabel('Principal Component'); ylabel('Eigenvalue');
title('PCA Eigenvalues (First 20 Components)');
grid on;

% Plot results using your functions
fprintf('Plotting Method 5 results...\n');
plotCscan(x, y, t, Data_pca_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 5: PCA Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_pca_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 5: PCA Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_pca_filt, defect_x, defect_y);
title(sprintf('Method 5: PCA Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 6: Adaptive Filtering with Defect-Free Reference
fprintf('\n=== Method 6: Adaptive Filtering with Defect-Free Reference ===\n');

% Define defect-free regions (avoid bottom edge where defects are)
defect_free_height = round(0.8 * size(Data,1)); % Top 80% of scan
Data_adaptive_filt = zeros(size(Data));

for k = 1:size(Data,3)
    if mod(k,200) == 0, fprintf('Progress: %d/%d\n', k, size(Data,3)); end
    slice = Data(:,:,k);
    % Use defect-free region as reference
    ref_region = slice(1:defect_free_height, :);
    background = mean(ref_region(:));
    Data_adaptive_filt(:,:,k) = slice - background;
end

% Plot results using your functions
fprintf('Plotting Method 6 results...\n');
plotCscan(x, y, t, Data_adaptive_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 6: Adaptive Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_adaptive_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 6: Adaptive Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_adaptive_filt, defect_x, defect_y);
title(sprintf('Method 6: Adaptive Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 7: Discrete Wavelet Transform (DWT) Denoising
fprintf('\n=== Method 7: Discrete Wavelet Transform (DWT) Denoising ===\n');

Data_dwt_filt = zeros(size(Data));
wavelet_name = 'db8'; % Daubechies 8 - good for ultrasonic signals
levels = 6; % Decomposition levels

fprintf('Processing DWT denoising...\n');
for i = 1:size(Data,1)
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, size(Data,1)); end
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Wavelet denoising with Bayesian method
        try
            Data_dwt_filt(i,j,:) = wdenoise(signal, levels, ...
                'Wavelet', wavelet_name, ...
                'DenoisingMethod', 'Bayes', ...
                'ThresholdRule', 'Soft', ...
                'NoiseVariance', 'estimate');
        catch
            % Fallback if wdenoise not available
            [c, l] = wavedec(signal, levels, wavelet_name);
            sigma = median(abs(c(1:l(1))))/0.6745;
            threshold = sigma * sqrt(2*log(length(signal)));
            c_thresh = wthresh(c, 's', threshold);
            Data_dwt_filt(i,j,:) = waverec(c_thresh, l, wavelet_name);
        end
    end
end

% Plot results using your functions
fprintf('Plotting Method 7 results...\n');
plotCscan(x, y, t, Data_dwt_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 7: DWT Denoised C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_dwt_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 7: DWT Denoised C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_dwt_filt, defect_x, defect_y);
title(sprintf('Method 7: DWT Denoised A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 8: Frequency Band Filtering with DWT (CORRECTED)
fprintf('\n=== Method 8: Frequency Band Filtering with DWT (CORRECTED) ===\n');

Data_dwt_band_filt = zeros(size(Data));
wavelet_name = 'db8';
levels = 6;

fprintf('Processing DWT band filtering...\n');
for i = 1:size(Data,1)
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, size(Data,1)); end
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Decompose signal
        [c, l] = wavedec(signal, levels, wavelet_name);
        
        % Zero out specific detail coefficients (CORRECTED APPROACH)
        levels_to_zero = [3, 4]; % Adjust based on frequency analysis
        
        for level = levels_to_zero
            if level <= levels
                % Get detail coefficients for this level (CORRECTED)
                d_coeffs = detcoef(c, l, level);
                
                % Find indices of detail coefficients for this level
                if level == 1
                    d_start = l(1) + 1;
                    d_end = l(1) + l(2);
                else
                    d_start = sum(l(1:level)) + 1;
                    d_end = sum(l(1:level+1));
                end
                
                % Zero out these coefficients
                c(d_start:d_end) = 0;
            end
        end
        
        % Reconstruct signal
        Data_dwt_band_filt(i,j,:) = waverec(c, l, wavelet_name);
    end
end

% Plot results using your functions
fprintf('Plotting Method 8 results...\n');
plotCscan(x, y, t, Data_dwt_band_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 8: DWT Band Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_dwt_band_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 8: DWT Band Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_dwt_band_filt, defect_x, defect_y);
title(sprintf('Method 8: DWT Band Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 9: Bandstop Filtering (SIMPLIFIED from CWT)
fprintf('\n=== Method 9: Multiple Bandstop Filtering (Simplified) ===\n');

Data_bandstop_filt = zeros(size(Data));

% Design multiple bandstop filters for different harmonics
fundamental_freq = f_standing;
harmonics = [1, 2, 3]; % 1st, 2nd, 3rd harmonics
filter_width = 0.3e6; % ±0.3 MHz around each harmonic

% Create combined filter
filter_order = 4;
combined_b = 1;
combined_a = 1;

for harm = harmonics
    center_freq = harm * fundamental_freq;
    f_range = [center_freq - filter_width, center_freq + filter_width];
    
    % Ensure frequencies are within Nyquist limit
    f_range = max(f_range, 100); % Avoid DC
    f_range = min(f_range, nyquist_freq * 0.95); % Stay below Nyquist
    
    [b_temp, a_temp] = butter(filter_order, f_range/nyquist_freq, 'stop');
    
    % Cascade filters
    combined_b = conv(combined_b, b_temp);
    combined_a = conv(combined_a, a_temp);
end

fprintf('Processing bandstop filtering...\n');
for i = 1:size(Data,1)
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, size(Data,1)); end
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        Data_bandstop_filt(i,j,:) = filtfilt(combined_b, combined_a, signal);
    end
end

% Plot results using your functions
fprintf('Plotting Method 9 results...\n');
plotCscan(x, y, t, Data_bandstop_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 9: Bandstop Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_bandstop_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 9: Bandstop Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_bandstop_filt, defect_x, defect_y);
title(sprintf('Method 9: Bandstop Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 10: 2D Wavelet Transform for Spatial Patterns (CORRECTED)
fprintf('\n=== Method 10: 2D Wavelet Transform for Spatial Patterns (CORRECTED) ===\n');

Data_2d_wavelet_filt = zeros(size(Data));
wavelet_name = 'db4'; % Shorter wavelet for 2D processing
decomp_levels = 3;

fprintf('Processing 2D wavelet filtering...\n');
for k = 1:size(Data,3)
    if mod(k,200) == 0, fprintf('Progress: %d/%d\n', k, size(Data,3)); end
    
    % Apply 2D wavelet transform to spatial slice
    slice = Data(:,:,k);
    
    % 2D wavelet decomposition (CORRECTED)
    [c, s] = wavedec2(slice, decomp_levels, wavelet_name);
    
    % Modify coefficients to remove large-scale spatial patterns
    % Remove approximation coefficients (low frequency spatial content)
    approx_size = s(1,1) * s(1,2);
    c(1:approx_size) = c(1:approx_size) * 0.1; % Reduce instead of zero
    
    % Optionally reduce some detail coefficients
    detail_start = approx_size + 1;
    horizontal_size = s(2,1) * s(2,2);
    c(detail_start:detail_start+horizontal_size-1) = ...
        c(detail_start:detail_start+horizontal_size-1) * 0.5;
    
    % Reconstruct with modified coefficients
    Data_2d_wavelet_filt(:,:,k) = waverec2(c, s, wavelet_name);
end

% Plot results using your functions
fprintf('Plotting Method 10 results...\n');
plotCscan(x, y, t, Data_2d_wavelet_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 10: 2D Wavelet Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_2d_wavelet_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 10: 2D Wavelet Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_2d_wavelet_filt, defect_x, defect_y);
title(sprintf('Method 10: 2D Wavelet Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 11: Adaptive Wavelet Thresholding
fprintf('\n=== Method 11: Adaptive Wavelet Thresholding ===\n');

Data_adaptive_wavelet_filt = zeros(size(Data));

fprintf('Processing adaptive wavelet thresholding...\n');
for i = 1:size(Data,1)
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, size(Data,1)); end
    for j = 1:size(Data,2)
        signal = squeeze(Data(i,j,:));
        
        % Wavelet decomposition
        [c, l] = wavedec(signal, 6, 'db8');
        
        % Estimate noise level from finest detail coefficients
        finest_detail = c(1:l(1));
        sigma = median(abs(finest_detail))/0.6745;
        
        % Calculate adaptive threshold (Donoho & Johnstone method)
        n = length(signal);
        threshold = sigma * sqrt(2*log(n));
        
        % Apply soft thresholding
        c_thresh = wthresh(c, 's', threshold);
        
        % Reconstruct
        Data_adaptive_wavelet_filt(i,j,:) = waverec(c_thresh, l, 'db8');
    end
end

% Plot results using your functions
fprintf('Plotting Method 11 results...\n');
plotCscan(x, y, t, Data_adaptive_wavelet_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 11: Adaptive Wavelet Thresholded C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_adaptive_wavelet_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 11: Adaptive Wavelet Thresholded C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_adaptive_wavelet_filt, defect_x, defect_y);
title(sprintf('Method 11: Adaptive Wavelet Thresholded A-scan at Position (%d,%d)', defect_x, defect_y));

%% Method 12: Pixel-wise FFT Phase Analysis for Standing Wave Removal
fprintf('\n=== Method 12: Pixel-wise FFT Phase Analysis ===\n');

% Parameters for phase analysis
nfft = 2^nextpow2(size(Data,3)); % Zero-pad for better frequency resolution
freq_range = [3e6, 8e6]; % Focus on standing wave frequency range
freq_axis = (0:nfft-1) * fs / nfft;
freq_indices = find(freq_axis >= freq_range(1) & freq_axis <= freq_range(2));

fprintf('FFT length: %d, Frequency range: %.1f-%.1f MHz\n', nfft, freq_range(1)/1e6, freq_range(2)/1e6);
fprintf('Number of frequency bins in range: %d\n', length(freq_indices));

% Initialize arrays
FFT_Data = zeros(nx, ny, nfft);
Phase_Data = zeros(nx, ny, length(freq_indices));
Amplitude_Data = zeros(nx, ny, length(freq_indices));

% Compute pixel-wise FFT
fprintf('Computing pixel-wise FFT...\n');
for i = 1:nx
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, nx); end
    for j = 1:ny
        signal = squeeze(Data(i,j,:));
        fft_signal = fft(signal, nfft);
        FFT_Data(i,j,:) = fft_signal;
        
        % Extract phase and amplitude in frequency range of interest
        fft_roi = fft_signal(freq_indices);
        Phase_Data(i,j,:) = angle(fft_roi);
        Amplitude_Data(i,j,:) = abs(fft_roi);
    end
end

% Analyze phase coherence for standing wave detection
fprintf('Analyzing phase coherence...\n');
coherence_map = zeros(nx, ny, length(freq_indices));
standing_wave_mask = zeros(nx, ny, length(freq_indices));

for f = 1:length(freq_indices)
    if mod(f,10) == 0, fprintf('Frequency progress: %d/%d\n', f, length(freq_indices)); end
    phase_slice = Phase_Data(:,:,f);
    
    % Compute local phase coherence (phase similarity with neighbors)
    for i = 2:nx-1
        for j = 2:ny-1
            % Get 3x3 neighborhood phases
            neighborhood_phases = phase_slice(i-1:i+1, j-1:j+1);
            center_phase = phase_slice(i,j);
            
            % Compute phase differences (handle wrapping)
            phase_diffs = angle(exp(1i*(neighborhood_phases - center_phase)));
            
            % Coherence = inverse of phase variance (higher coherence = more standing wave-like)
            coherence_map(i,j,f) = 1 / (var(phase_diffs(:)) + 1e-6);
        end
    end
    
    % Create standing wave mask based on high coherence
    coherence_threshold = prctile(coherence_map(:,:,f), 85); % Top 15% most coherent
    standing_wave_mask(:,:,f) = coherence_map(:,:,f) > coherence_threshold;
end

% Method 12a: Phase-Coherence Based Filtering
Data_phase_coherence_filt = zeros(size(Data));
fprintf('Applying phase-coherence filtering...\n');

for i = 1:nx
    if mod(i,10) == 0, fprintf('Progress: %d/%d\n', i, nx); end
    for j = 1:ny
        signal = squeeze(Data(i,j,:));
        fft_signal = fft(signal, nfft);
        
        % Apply mask to remove coherent (standing wave) frequencies
        for f = 1:length(freq_indices)
            freq_idx = freq_indices(f);
            if standing_wave_mask(i,j,f)
                % Reduce amplitude at this frequency
                fft_signal(freq_idx) = fft_signal(freq_idx) * 0.1;
                % Handle negative frequencies (conjugate symmetry)
                if freq_idx > 1 && freq_idx <= nfft/2
                    fft_signal(nfft - freq_idx + 2) = fft_signal(nfft - freq_idx + 2) * 0.1;
                end
            end
        end
        
        % Reconstruct signal
        filtered_signal = ifft(fft_signal);
        Data_phase_coherence_filt(i,j,:) = real(filtered_signal(1:nt));
    end
end

% Method 12b: Spatial Phase Gradient Filtering
fprintf('Computing spatial phase gradients...\n');
Data_phase_gradient_filt = zeros(size(Data));

% Find dominant standing wave frequency
avg_amplitude = squeeze(mean(mean(Amplitude_Data, 1), 2));
[~, dominant_freq_idx] = max(avg_amplitude);
dominant_phase = Phase_Data(:,:,dominant_freq_idx);
dominant_freq_val = freq_axis(freq_indices(dominant_freq_idx));

fprintf('Dominant frequency: %.2f MHz\n', dominant_freq_val/1e6);

% Compute phase gradients
[phase_grad_x, phase_grad_y] = gradient(dominant_phase);
phase_grad_magnitude = sqrt(phase_grad_x.^2 + phase_grad_y.^2);

% Create spatial filter based on phase gradients
% High gradient regions = standing wave boundaries
gradient_threshold = prctile(phase_grad_magnitude(:), 75);
spatial_mask = phase_grad_magnitude > gradient_threshold;

fprintf('Phase gradient threshold: %.4f\n', gradient_threshold);
fprintf('Pixels with high phase gradients: %d/%d (%.1f%%)\n', sum(spatial_mask(:)), numel(spatial_mask), 100*sum(spatial_mask(:))/numel(spatial_mask));

% Apply spatial filtering
for k = 1:nt
    if mod(k,200) == 0, fprintf('Time slice progress: %d/%d\n', k, nt); end
    slice = Data(:,:,k);
    filtered_slice = slice;
    
    % Smooth regions with high phase gradients
    if any(spatial_mask(:))
        for i = 1:nx
            for j = 1:ny
                if spatial_mask(i,j)
                    % Apply local median filter to high-gradient regions
                    local_region = slice(max(1,i-1):min(nx,i+1), max(1,j-1):min(ny,j+1));
                    filtered_slice(i,j) = median(local_region(:));
                end
            end
        end
    end
    
    Data_phase_gradient_filt(:,:,k) = filtered_slice;
end

% Visualization: Phase Maps
figure('Name', 'Phase Analysis - Method 12');

% Plot phase at dominant frequency
subplot(2,3,1);
imagesc(x, y, dominant_phase.');
title(sprintf('Phase at %.2f MHz', dominant_freq_val/1e6));
xlabel('X position'); ylabel('Y position');
colorbar; colormap(gca, hsv); axis equal tight;

% Plot coherence map
subplot(2,3,2);
imagesc(x, y, coherence_map(:,:,dominant_freq_idx).');
title('Phase Coherence Map');
xlabel('X position'); ylabel('Y position');
colorbar; colormap(gca, parula); axis equal tight;

% Plot standing wave mask
subplot(2,3,3);
imagesc(x, y, standing_wave_mask(:,:,dominant_freq_idx).');
title('Standing Wave Mask');
xlabel('X position'); ylabel('Y position');
colorbar; colormap(gca, gray); axis equal tight;

% Plot phase gradients
subplot(2,3,4);
imagesc(x, y, phase_grad_magnitude.');
title('Phase Gradient Magnitude');
xlabel('X position'); ylabel('Y position');
colorbar; colormap(gca, parula); axis equal tight;

% Plot frequency spectrum at center pixel
subplot(2,3,5);
center_spectrum = squeeze(Amplitude_Data(round(nx/2), round(ny/2), :));
plot(freq_axis(freq_indices)/1e6, center_spectrum);
xlabel('Frequency (MHz)'); ylabel('Amplitude');
title('Frequency Spectrum (Center Pixel)');
grid on;

% Plot coherence vs frequency
subplot(2,3,6);
avg_coherence = squeeze(mean(mean(coherence_map, 1), 2));
plot(freq_axis(freq_indices)/1e6, avg_coherence);
xlabel('Frequency (MHz)'); ylabel('Average Coherence');
title('Coherence vs Frequency');
grid on;

% Plot results using your functions
fprintf('Plotting Method 12a results...\n');
plotCscan(x, y, t, Data_phase_coherence_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 12a: Phase Coherence Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_phase_coherence_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 12a: Phase Coherence Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_phase_coherence_filt, defect_x, defect_y);
title(sprintf('Method 12a: Phase Coherence Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

fprintf('Plotting Method 12b results...\n');
plotCscan(x, y, t, Data_phase_gradient_filt, actual_toi1, actual_toi1, gateopt, th_gate, gateside);
title(sprintf('Method 12b: Phase Gradient Filtered C-scan at toi1 = %.2f μs', actual_toi1));

plotCscan(x, y, t, Data_phase_gradient_filt, actual_toi2, actual_toi2, gateopt, th_gate, gateside);
title(sprintf('Method 12b: Phase Gradient Filtered C-scan at toi2 = %.2f μs', actual_toi2));

plotAscan(t, Data_phase_gradient_filt, defect_x, defect_y);
title(sprintf('Method 12b: Phase Gradient Filtered A-scan at Position (%d,%d)', defect_x, defect_y));

%% Summary and Recommendations
fprintf('\n=== FILTERING METHOD SUMMARY ===\n');
fprintf('Method 1: Background Subtraction - Simple, effective for uniform backgrounds\n');
fprintf('Method 2: Temporal Moving Average - Good for time-varying standing waves\n');
fprintf('Method 3: Spatial Median - Removes spatially coherent patterns\n');
fprintf('Method 4: Frequency Domain - Precise frequency targeting\n');
fprintf('Method 5: PCA - Powerful but computationally intensive\n');
fprintf('Method 6: Adaptive - Uses defect-free regions as reference\n');
fprintf('Method 7: DWT Denoising - Automatic noise reduction\n');
fprintf('Method 8: DWT Band Filtering - Selective frequency removal\n');
fprintf('Method 9: Bandstop Filtering - Multiple harmonic removal\n');
fprintf('Method 10: 2D Wavelet - Spatial pattern removal\n');
fprintf('Method 11: Adaptive Wavelet - Automatic threshold selection\n');
fprintf('Method 12a: Phase Coherence - Removes spatially coherent phase patterns\n');
fprintf('Method 12b: Phase Gradient - Targets standing wave boundaries\n');
fprintf('\nRecommended starting methods: 1, 4, 5, 12a\n');
fprintf('For your horizontal banding: 12a, 12b\n');

fprintf('\nAll filtering methods completed successfully!\n');
fprintf('Phase analysis complete - check coherence maps for standing wave patterns\n');
